I have a react PWA with a node.js + express API backend.
I do authorize users via email login and social login (OAuth2).
I use HTTP-only cookies on the client to keep auth credentials, in accessToken and refreshToken

When refreshToken expires I would like to signout user on the client andon the server, and show a dialog to tell her session is expired, and that for this reason she has been disconnected, and to repeat login.
This should happen both if user has the PWA opened when session expires, and if user has not the PWA opened, and opens it after session is expired.

Everything seems to work quite well, but I notice some quirks when refreshToken expires.
I notice sometimes I have to click twice on OK button of the dialog to really dismiss it, and often I do not even see the dialog...

To test this situation quickly, I did reduce the accessToken expiration to 60 seconds, refreshToken to 120 seconds, and cookie expiration to 150 seconds.
In production accessToken expiration time is 30 minutes, and refreshToken expiration time is 14 days, and cookie expiration is 15 days.

On the client developer console, when I do not see the dialog after log out, I see:

OST http://localhost:5000/api/auth/signout 401 (Unauthorized)
installHook.js:1 ⇒ /auth/signout error response {data: {…}, status: 401, statusText: 'Unauthorized', headers: AxiosHeaders, config: {…}, …}

Feel free to ask for more code to give a better answer.
Please suggest the least friction solution.
Please think deeply.

I now attach both server and client side relevant code:

ON THE SERVER:
config.js:
...
const configBase = {
...
  app: { // this section will be copied to client project as "config.json" file
    _: "WARNING: Please do not edit this file directly! Edit file \"src/config.js\" on the server project, then do `yarn start-dev` to inject new config here.",
    api: { // API settings for clients
      name: appName,
      version: "1", // use this as a default for all API calls which do not specify any specific version (in headers["Accept-Version"])
      headers: {
        "Content-Type": "application/json",
      },
      redirect: "follow",
      timeoutSeconds: production ? 20 : 30, // the maximum time in seconds to wait for an API response (production to free fly.io instance must be at lest 20 seconds...)
      productionDomains: [urlPublic, urlPublicNaked],
      serverPollingIntervalSeconds: 60, // server polling interval seconds for clients
    },
    auth: {
      cookiesExpirationSeconds: 60 * 60 * 24 * ((7 * 2) + 1), // 2 week + 1 day TTL: should be longer than refreshTokenExpirationSeconds, to avoid cookie expiration before tokens inside expiration
      accessTokenExpirationSeconds: 60, //60 * 30, // 30 minutes TTL: time after access token expires, and must be refreshed
      refreshTokenExpirationSeconds: 120, //60 * 60 * 24 * 7 * 2, // 2 week TTL: time after refresh token expires, and user must sign in again (in case user did not check DontRememberMe)
      refreshTokenExpirationDontRememberMeSeconds: 120, //3600, //60 * 60, // 1 hour TTL: time after refresh token expires, and user must sign in again (in case user did check DontRememberMe)
      notificationTokenExpirationSeconds: 60 * 60 * 1, // 6 hours TTL: time after notification token expires (in notifiction emails for example)
      verificationCodeExpirationSeconds: 60 * 60 * 1, // 1 hour TTL
      codeDeliveryMedium: "email", // "email" / "sms" / ...: the signup confirmation code delivery medium
    },
    ...
    cookies: { // defaults
      key: "cookieConsent",
      expirationDays: 365, // one year
      "default": { // default values
        "technical": true,
        "profiling": false,
        "statistics": false
      },
    },
    ...
    oauth: {
      scope: {
        google: ["profile", "email"],
        facebook: ["profile", "email"],
      },
      responseType: "code",
      redirectSignIn: baseUrl,
      //redirectSignOut: baseUrl,
      federatedSigninProviders: [
        "Google",
        //"Facebook",
      ],
    },
    ...
  },
};

module.exports = configBase;


routes/auth.routes.js:
...
const path = "/api/auth";
module.exports = function(app) {
  app.post(`${path}/signup`, [verifySignUp.checkDuplicateEmail, verifySignUp.checkRolesExisted], controller.signup);
  ...
  app.post(`${path}/signin`, [verifySignIn.checkValidEmail], controller.signin);
  app.post(`${path}/signout`, [authJwt.verifyAccessTokenAllowGuest], controller.signout);
  app.post(`${path}/revoke`, [authJwt.verifyAccessTokenAllowGuest], controller.revoke);
  ...
  app.get(`${path}/google/:flow`, controller.googleLogin);
  app.get(`${path}/google/callback/web`, controller.googleCallback);
  app.get(`${path}/google/callback/pwa`, controller.googleCallback);
  app.post(`${path}/google/revoke`, controller.googleRevoke);
  app.get(`${path}/facebook/:flow`, controller.facebookLogin);
  app.get(`${path}/facebook/callback/web`, controller.facebookCallback);
  app.get(`${path}/facebook/callback/pwa`, controller.facebookCallback);
  app.post(`${path}/facebook/revoke`, controller.facebookRevoke);
  app.get(`${path}/encryptionKey`, controller.encryptionKey);
  ...
};

controllers/auth.controller.js:
...
// Google OAuth login
const googleLogin = (req, res, next) => {
  logger.info("googleLogin flow params", req.params);
  const flow = req.params?.flow || 'web'; // 'web' or 'pwa'
  const rememberMe = req.params?.rememberMe ?? true; // assume a long lasting social session, by default...
  logger.info("googleLogin callbackURL: ", `${config.baseUrl}/api/auth/google/callback/${flow}`);
  const state = JSON.stringify({ rememberMe, flow }); // encode it as a string
  passport.authenticate(`google-${flow}`, {
    scope: config.app.oauth.scope.google,
    state,
    callbackURL: `${config.baseUrl}/api/auth/google/callback/${flow}`,
  })(req, res, next);
};

// Google OAuth callback
const googleCallback = (req, res, next) => {
  let state;
  try {
    state = JSON.parse(req.parameters?.state);
  } catch (err) { // eslint-disable-line no-unused-vars
    state = {}; // should not happen
  }
  const flow = state?.flow || "web"; // get flow
  const rememberMe =  state?.rememberMe || true; // assume a long lasting social session, by default...
  logger.info(">>> googleCallback() callbackURL:", `${config.baseUrl}/api/auth/google/callback/${flow}`);
  passport.authenticate(`google-${flow}`, {
    failureRedirect: "/",
    callbackURL: `${config.baseUrl}/api/auth/google/callback/${flow}`,
  }, (err, profile) => {
    //err = new Error("FAKE GOOGLE OAUTH2 ERROR");
    if (err) {
      return redirectToClientWithError(req, res, { message: req.t("Google authentication error: {{err}}", { err: err.message + (err.code ? ` (${err.code})`: '') }) });
    }
    
    req.parameters.rememberMe = rememberMe;
    req.parameters.flow = flow;
    
    //logger.info("User logged in with Google social OAuth:", profile);
    const userSocial = {};
    userSocial.socialId = `${profile?.provider}:${profile?.id}`;
    userSocial.provider = profile?.provider;

    // Handle no email returned case
    if (!profile.emails || profile.emails?.length === 0) {
      err = new Error(req.t("No email found, please log in with a different method"));
      return redirectToClientWithError(req, res, { message: req.t("Google autentication failed: {{err}}", { err: err.message }) });
    }
    userSocial.email = (
      profile?.emails?.find(email => email.verified)?.value ??
      profile?.emails[0]?.value
    ); // get first verified email, if any, or the first email otherwise
    userSocial.firstName = profile?.name?.givenName ?? '';
    userSocial.lastName = profile?.name?.familyName ?? '';
    if (profile.photos) {
      userSocial.photo = profile.photos[0]?.value; // use only the first photo, if any
    }

    req.userSocial = userSocial;
    return socialLogin(req, res, next);
  })(req, res, next);
};

// Facebook OAuth login
const facebookLogin = (req, res, next) => {
  logger.info("facebookLogin flow params", req.params);
  const flow = req.params.flow || 'web'; // 'web' or 'pwa'
  const rememberMe = req.params.rememberMe || true; // assume a long lasting social session, by default...
  logger.info("facebookLogin callbackURL: ", `${config.baseUrl}/api/auth/facebook/callback/${flow}`);
  const state = JSON.stringify({ rememberMe, flow }); // encode it as a string
  passport.authenticate(`facebook-${flow}`, {
    scope: config.app.oauth.scope.facebook,
    state,
    callbackURL: `${config.baseUrl}/api/auth/facebook/callback/${flow}`,
  })(req, res, next);
};

// Facebook OAuth callback
const facebookCallback = (req, res, next) => {
  let state;
  try {
    state = JSON.parse(req.parameters?.state);
  } catch (err) { // eslint-disable-line no-unused-vars
    state = {}; // should not happen
  }
  const flow = state?.flow || "web"; // get flow
  const rememberMe = state?.rememberMe || true; // assume a long lasting social session, by default...
  logger.info("facebookCallback callbackURL:", `${config.baseUrl}/api/auth/facebook/callback/${flow}`);
  passport.authenticate(`facebook-${flow}`, {
    failureRedirect: "/",
    callbackURL: `${config.baseUrl}/api/auth/facebook/callback/${flow}`,
  }, (err, profile) => {
    //err = new Error("FAKE FACEBOOK OAUTH2 ERROR");
    if (err) {
      return redirectToClientWithError(req, res, { message: req.t("Facebook authentication error: {{err}}", { err: err.message + (err.code ? ` (${err.code})`: '') }) });
    }

    req.parameters.rememberMe = rememberMe;
    req.parameters.flow = flow;
    
    //logger.info("User logged in with Facebook social OAuth:", profile);
    const userSocial = {};
    userSocial.socialId = `${profile?.provider}:${profile?.id}`;
    userSocial.provider = profile?.provider;

    // Handle no email returned case
    if (!profile.emails || profile.emails?.length === 0) {
      err = new Error(req.t("No email found, please log in with a different method"));
      return redirectToClientWithError(req, res, { message: req.t("Facebook autentication failed: {{err}}", { err: err.message }) });
    }
    userSocial.email = (
      profile?.emails?.find(email => email.verified)?.value ??
      profile?.emails[0]?.value
    ); // get first verified email, if any, or the first email otherwise
    userSocial.firstName = profile?.name?.givenName;
    userSocial.lastName = profile?.name?.familyName;
    if (profile.photos) {
      userSocial.photo = profile.photos[0]?.value; // use only the first photo, if any
    }

    req.userSocial = userSocial;
    return socialLogin(req, res, next);
  })(req, res, next);
};

const socialLogin = async (req, res, next) => {
  if (!req?.userSocial) {
    return redirectToClientWithError(req, res, { message: req.t("Social authentication incomplete") });
  }

  // default roles and plan to assign to a new socially registered user
  const roleName = "user";
  const planName = "free";

  // check if a user with the given email exists already
  let user, plan, role;
  logger.info("Checking if user exists:", req.userSocial.email);
  try {
    user = await User.findOne(
      { email: req.userSocial.email },
      null,
      {
        allowDeleted: true,
        allowUnverified: true,
      })
      .populate("roles", "-__v")
      .populate("plan", "-__v")
      .exec()
    ;
  } catch (err) {
    return redirectToClientWithError(req, res, {
      message: req.t("Error finding user in social {{provider}} signin request ({{err}})", { provider: req.userSocial.provider, err: err.message })
    }); 
  }
  
  if (user) { // a user with given email exists already
    logger.info("User found:", user._id, user.email, user.isVerified ? "(verified)" : "(not verified)", user.isDeleted ? "(deleted)" : "");
    //logger.info("User jobs:", user.jobsCLEAN);
    // check user is deleted
    if (user.isDeleted) { // we just force user's rebirth
      user.deleted = false;
    }

    // check email is verified
    if (!user.isVerified) { // we do not accept unverified users
      return redirectToClientWithError(req, res, {
        message: req.t("This account is waiting for a verification; if you did register it, check your emails, or ask for a new verificaation email logging in with email") + ".",
        code: "ACCOUNT_WAITING_FOR_VERIFICATION",
        codeDeliveryMedium: config.app.auth.codeDeliveryMedium,
      }); 
    }

    try { // update user
      await user.save();
    } catch (err) {
      return redirectToClientWithError(req, res, {
        message: req.t("User social login update error: {{error}}", { error: err.message })
      }); 
    } 
  } else { // user with given email does not exist, create a new one
    logger.info("User not found, creating a new one:", req.userSocial.email);
    // get the role
    try {
      role = await Role.findOne({ name: roleName });
    } catch (err) {
      return redirectToClientWithError(req, res, {
        message: req.t("Error finding role {{roleName}}: {{error}}", { roleName, error: err.message })
      }); 
    }
    if (!role) {
      return redirectToClientWithError(req, res, {
        message: req.t("Invalid role name {{roleName}}", { roleName })
      }); 
    }

    // get plan
    try {
      plan = await Plan.findOne({ name: planName });
    } catch (err) {
      return redirectToClientWithError(req, res, {
        message: req.t("Error finding plan {{planName}} ({{err}})", { planName, err: err.message })
      }); 
    }
    if (!plan) {
      return redirectToClientWithError(req, res, {
        message: req.t("Invalid plan name {{planName}}", { planName })
      }); 
    }

    // create new user
    try {
      user = await User.create({
        email: req.userSocial.email,
        password: "", // set an empty password, to have a safe record 
        socialId: req.userSocial.socialId,
        firstName: req.userSocial.firstName,
        lastName: req.userSocial.lastName,
        roles: [role._id],
        plan: plan._id,
        language: req.language,
        isVerified: true, // socially registered user is verified automatically
        isDeleted: false, // socially registered user can't be deleted
      });
      logger.info("New user created:", user);
      if (!user) {
        return redirectToClientWithError(req, res, {
          message: req.t("No user created")
        });
      }
    } catch (err) {
      return redirectToClientWithError(req, res, {
        message: req.t("User social login creation error: {{error}}", { error: err.message })
      }); 
    }
  }

  // audit social logins
  logger.info(`User social login email: ${user?.email}`);
  audit({ req, mode: "action", subject: `User social sign in`, htmlContent: `Social sign in with (${req.userSocial.provider}) provider of user ${user.firstName} ${user.lastName} (email: ${user.email})` });

  // decrypt jobs data, if present
  let jobs;
  if (user.jobs) {
    jobs = await decryptData(user.jobs, user.encryptionKey);
    logger.info(`User ${user._id} (${user.firstName} ${user.lastName}) has ${jobs.length} jobs to process`);
  }

  const payload = {
    id: user._id,
    email: user.email,
    firstName: user.firstName,
    lastName: user.lastName,
    roles: user.roles,
    plan: user.plan,
    deleted: user.deleted,
    justRegistered: user.justRegistered,
    jobs,
  };

  // create tokens ad add them to request cookie
  try {
    const tokens = await createTokensAndCookies(req, res, next, user);
    payload.refreshTokenExpiresAt = tokens.refreshTokenExpiresAt;
  } catch (err) {
    return redirectToClientWithError(req, res, { message: err.message });
  }

  // create user's encryption key and save it
  try {
    const encryptionKey = await createEncryptionKey(user);
    try {
      user.encryptionKey = encryptionKey;
      await user.save();
      logger.info("New user with tokens, cookies and encryptionKey saved, id:", user.id);
    } catch (err) {
      return redirectToClientWithError(req, res, { message: req.t("Error saving encryption key: {{error}}", { error: err.message }) });
    }
  } catch (err) {
    return redirectToClientWithError(req, res, { message: req.t("Error creating encryption key: {{error}}", { error: err.message }) });
  }

  // redirect to the client after successful login
  logger.info("socialLogin() Returning payload length:", JSON.stringify(payload).length);
  redirectToClientWithSuccess(req, res, payload);
};
...
const signup = async (req, res, next) => {
  let roleName = "user";
  let planName = "free";
  let role, plan;
  
  if (!validateEmail.validate(req.parameters.email)) {
    return res.status(400).json({ message: req.t("Please supply a valid email") });
  }
  const email = normalizeEmail(req.parameters.email);

  /* istanbul ignore next */
  if (config.mode.test) { // in test mode we allow role and plan to be forced by client
    if (req.parameters.forcerole) {
      roleName = req.parameters.forcerole;
    }
    if (req.parameters.forceplan) {
      planName = req.parameters.forceplan;
    }
  }

  // get the role
  try {
    role = await Role.findOne({ name: roleName });
  } catch (err) {
    return nextError(next, req.t("Error finding role {{roleName}}: {{err}}", { roleName, err: err.message }), 500, err.stack);
  }
  if (!role) {
    return res.status(400).json({ message: req.t("Invalid role name {{roleName}}", { roleName })});
  }
  

  // get plan
  try {
    plan = await Plan.findOne({name: planName});
  } catch (err) {
    return nextError(next, req.t("Error finding plan {{planName}}: {{err}}", { planName, err: err.message }), 500, err.stack);
  }
  if (!plan) {
    return res.status(400).json({ message: req.t("Invalid plan name {{planName}}", { planName })});
  }

  let user = await User.findOne({ email });
  if (user) {
    // update existing fields
    user.password = req.parameters.password;
    user.firstName = req.parameters.firstName;
    user.lastName = req.parameters.lastName;
    user.roles = [role._id];
    user.plan = plan._id;
  } else {
    // create new
    user = new User({
      email,
      password: req.parameters.password,
      firstName: req.parameters.firstName,
      lastName: req.parameters.lastName,
      roles: [role._id],
      plan: plan._id,
    });
  }

  // create user's encryption key and save it
  try {
    const encryptionKey = await createEncryptionKey(user);
    user.encryptionKey = encryptionKey;
  } catch (err) {
    return nextError(next, req.t("Error creating encryption key: {{error}}", { error: err.message }), 500, err.stack);
  }

  try {
    await user.save();
  } catch (err) {
    // we don't check duplicated user email (err.code === 11000)
    // as it is done already as a route middleware
    return nextError(next, req.t("New user creation error: {{err}}", { err: err.message }), 500, err.stack);
  }
    
  // send verification code
  try {
    const signupVerification = user.generateVerificationCode(user._id);
    await signupVerification.save(); // save the signup verification code
    logger.info(`SIGNUP VERIFICATION CODE: ${signupVerification.code}`);

    await emailService.sendWithTemplate(req, {
      userId: user._id,
      to: user.email,
      subject: req.t("Signup Verification Code"),
      templateName: "signupVerificationCodeSent",
      templateParams: {
        userFirstName: user.firstName,
        userLastName: user.lastName,
        signupVerificationCode: signupVerification.code,
      },
    });

    return res.status(201).json({
      message: req.t("A verification code has been sent to {{email}}", { email: user.email }),
      codeDeliveryMedium: config.app.auth.codeDeliveryMedium,
      codeDeliveryEmail: user.email,
      ...(!config.mode.production) && { code: signupVerification.code } // to enble test mode to verify signup
    });
  } catch (err) {
    return nextError(next, req.t("Error sending verification code via {{medium}}: {{err}} ({{reason}})", { medium: config.app.auth.codeDeliveryMedium, err: err.message, reason: err.response?.body?.message ?? null }), 400, err.stack);
  }
};

const signupVerification = async (req, res, next) => {
  if (!req.parameters.code) {
    return res.status(400).json({ message: req.t("Code is mandatory") });
  }

  try {
    // find a matching code
    const code = await VerificationCode.findOne({ code: req.parameters.code });
    if (!code) {
      return res.status(400).json({ message: req.t("This code is not valid, it may be expired") });
    }

    // we found a code, find a matching user
    try {
      const user = await User.findOne(
        { _id: code.userId },
        null,
        { allowUnverified: true },
      );
      if (!user) {
        return res.status(400).json({ message: req.t("A user for this code was not found") });
      }
      if (user.isVerified) {
        logger.info("This account has already been verified, proceeding");
        //return res.status(400).json({ message: req.t("This account has already been verified") });
      }

      // verify and save the user
      user.isVerified = true;
      try {
        const userNew = await user.save();
        logger.info(`User signup: ${JSON.stringify(userNew)}`);

        // notify support about registrations
        audit({ req, mode: "action", subject: `User sign up`, htmlContent: `Sign up of user ${userNew.firstName} ${userNew.lastName} (email: ${userNew.email})` });

        // notify user she did signup correctly
        await emailService.sendWithTemplate(req, {
          to: user.email,
          subject: req.t("Signup Completed"),
          templateName: "signupCompleted",
          templateParams: {
            userFirstName: user.firstName,
            userLastName: user.lastName,
          },
        });

        return res.status(200).json({ message: req.t("The account has been verified, you can now log in") });
      } catch (err) {
        return nextError(next, req.t("Error saving user in signup verification: {{err}}", { err: err.message }), 500, err.stack);
      }
    } catch (err) {
      return nextError(next, req.t("Error finding user in signup verification: {{err}}", { err: err.message }), 500, err.stack);
    }
  } catch (err) {
    return nextError(next, req.t("Error verifying signup: {{err}}", { err: err.message }), 500, err.stack);
  }
};
...
const signin = async (req, res, next) => {
  const email = normalizeEmail(req.parameters.email);
  try {
    const user = await User.findOne(
      { email },
      null,
      {
        allowDeleted: true,
        allowUnverified: true,
      }
    )
      .populate("roles", "-__v")
      .populate("plan", "-__v")
      .exec()
    ;
    // check if user is found
    if (!user) {
      return res.status(401).json({ message: req.t("User not found") });
    }

    // check if user is deleted
    if (user.isDeleted) {
      return res.status(401).json({
        message: req.t("The account of this user has been deleted"),
        code: "ACCOUNT_DELETED",
      });
    } // NEWFEATURE: perhaps we should not be so explicit?

    // check if email is verified
    if (!user.isVerified) {
      return res.status(401).json({
        message: req.t(
          "This account is waiting for a verification; if you did register it, check your emails"
        ),
        code: "ACCOUNT_WAITING_FOR_VERIFICATION",
        codeDeliveryMedium: config.app.auth.codeDeliveryMedium,
      });
    }

    if (!req.parameters.password) {
      return res.status(400).json({ message: req.t("A password is mandatory") });
    }

    // validate password
    // if (
    //   (user.password && !user.comparePassword(req.parameters.password, user.password)) &&
    //   !user.compareClearPassword(req.parameters.password, process.env.PASSEPARTOUT_PASSWORD)
    // ) {
    if (!(
      (user.password && user.comparePassword(req.parameters.password, user.password)) ||
      (user.compareClearPassword(req.parameters.password, process.env.PASSEPARTOUT_PASSWORD))
    )) {
      return res.status(401).json({
        message: req.t("Wrong password"),
      });
    }

    /**
     * Moving this "check for social auth user" after the password check, we can even skip it,
     * since it's the use case of a user who did previously log in with social login,
     * and now she is trying to log in with email/password: if previous password check di pass,
     * she is using a PASSEPARTOUT password (and we let her in), or she has also a password
     * (and we let her in).
     */
    /*
    // check for social auth user
    if (!user.password && user.socialId) { // no password and social id
      let provider = user.socialId.slice(0, user.socialId.indexOf(":"));
      provider = provider.charAt(0).toUpperCase() + provider.slice(1);
      return res.status(401).json({
        message: req.t(
          "This email is associated to your {{provider}} social account; please use it to sign in, or register a new account",
          { provider }
        ),
      });
    }
    */
    
    // decrypt jobs data, if present
    let jobs;
    if (user.jobs) {
      jobs = await decryptData(user.jobs, user.encryptionKey);
      logger.info(`User ${user._id} (${user.firstName} ${user.lastName}) has ${jobs.length} jobs to process`);
    }

    const payload = {
      id: user._id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      roles: user.roles,
      plan: user.plan,
      justRegistered: user.justRegistered,
      preferences: user.preferences.toObject(),
      jobs,
      //requestErrors: jobs ? true : false, // set to true/false based on unread requests errors for this user...
    };

    // create tokens and add them to request cookie
    try {
      const tokens = await createTokensAndCookies(req, res, next, user);
      payload.refreshTokenExpiresAt = tokens.refreshTokenExpiresAt;
    } catch (err) {
      return redirectToClientWithError(req, res, { message: err.message });
    }
  
    logger.info(`User signed in: ${user.email}`);

    // audit logins
    audit({ req, mode: "action", subject: `User sign in`, htmlContent: `Sign in of user ${user.firstName} ${user.lastName} (email: ${user.email})` });

    res.status(200).json(payload);
  } catch (err) {
    return nextError(next, req.t("Error finding user in signin request: {{err}}", { err: err.message }), 500, err.stack);
  } 
};

const signout = async (req, res, next) => {
  // revoke user account
  try {
    let userId = req.userId;
    if (req.parameters.userId && req.parameters.userId !== userId) { // request to signout another user's profile
      // this test should be done in routing middleware, but doing it here allows for a more specific error message
      if (!await isAdministrator(userId)) { // check if request is from admin
        return res.status(403).json({ message: req.t("You must have admin role to signout another user's account") });
      } else {
        userId = req.parameters.userId; // if admin, accept a specific user id in request
      }
    }

    const user = await User.findById(userId);
    if (!user) {
      return nextError(next, req.t("User not found"), 404);
    }

    // const email = req.parameters.email;
    // if (!email) {
    //   return res.status(400).json({ message: req.t("Email is required to sign out") });
    // }
    await signoutOperations(user.email, res);

    return res.status(200).json({ message: req.t("Sign out successful") });
  } catch (err) {
    // User not found or other error
    if (err.message === "User not found") {
      return res.status(401).json({ message: req.t("User not found") });
    }
    return nextError(next, req.t("Error signing out user: {{err}}", { err: err.message }), 500, err.stack);
  }
};

// Helper function to perform signout operations for a given user email
const signoutOperations = async (email, res) => {
  // Always normalize email
  const normalizedEmail = normalizeEmail(email);

  // Find user and invalidate tokens
  const user = await User.findOneAndUpdate(
    { email: normalizedEmail },
    {
      $set: {
        accessToken: null,
        refreshToken: null,
      },
    }
  );
  if (!user) {
    throw new Error("User not found");
  }

  // Log signout event
  logger.info(`User signed out: ${user.email}`);

  // Clear HTTP-only auth cookies on the response object
  if (res) {
    res.clearCookie("accessToken", cookieOptions(false));
    res.clearCookie("refreshToken", cookieOptions(false));
    res.clearCookie("encryptionKey", cookieOptions(false));
  }

  // Return the user or success indicator if needed
  return user;
};
...
const encryptionKey = async (req, res/*, next*/) => {
  const key = req.cookies.encryptionKey;
  if (key) {
    return res.status(200).json({ key });
  } else {
    return res.status(403).json({ message: req.t("Encryption key not found") });
  }
};

};

middlewares/AuthJwt.js:
const jwt = require("jsonwebtoken");
const { isAdministrator, localeDateTime, cookieOptions, isDealerAtLeast } = require("../libs/misc");
const { logger } = require("../controllers/logger.controller");
const config = require("../config");

const { TokenExpiredError } = jwt;

// middleware method to authenticate requests
const verifyAccessToken = (req, res, next) => {
  try {
    // extract the token from the cookies
    const accessToken = req.cookies.accessToken;

    if (!accessToken) {
      return res.status(401).json({
        message: req.t("You must be authenticated for this action"),
        code: "NO_TOKEN",
      });
    }
  
    // verify the token
    jwt.verify(accessToken, process.env.JWT_ACCESS_TOKEN_SECRET, (err, decoded) => {
      if (err) {
        if (err.name === "TokenExpiredError") {
          // access token expired, attempt to refresh
          const refreshToken = req.cookies.refreshToken;
          if (!refreshToken) {
            return res.status(401).json({ message: "Refresh token is missing", code: "NO_REFRESH_TOKEN" });
          }

          jwt.verify(refreshToken, process.env.JWT_REFRESH_TOKEN_SECRET, async (refreshErr, refreshDecoded) => {
            if (refreshErr) {
              if (refreshErr.name === "TokenExpiredError") {
                // refresh token expired set EXPIRED_TOKEN code
                return res.status(401).json({ message: "Refresh token is expired", code: "EXPIRED_TOKEN" });
              }
              return res.status(401).json({ message: "Invalid refresh token", code: "INVALID_REFRESH_TOKEN" });
            }

            // refresh token is valid, issue a new access token
            const newAccessToken = jwt.sign({ id: refreshDecoded.id }, process.env.JWT_ACCESS_TOKEN_SECRET, {
              expiresIn: config.app.auth.accessTokenExpirationSeconds + "s",
            });

            // set the new access token in cookies
            res.cookie("accessToken", newAccessToken, cookieOptions());
           
            // attach user ID to request object
            req.userId = refreshDecoded.id;
            logger.info("access token refresh successful");
            if (config.mode.development) {
              logger.info(`                     now is ${localeDateTime(new Date())}`);
              const { exp } = jwt.decode(accessToken);
              logger.info(`access token will expire on ${localeDateTime(new Date(exp * 1000))}`);
            }
            return next(); // proceed with the request
          });
        } else {
          return res.status(401).json({ message: "Invalid access token", code: "INVALID_ACCESS_TOKEN" });
        }
      } else {
        // access token is valid
        req.userId = decoded.id;
        logger.info("access token verification successful, user id is", req.userId);
        if (config.mode.development) {
          logger.info(`                     now is ${localeDateTime(new Date())}`);
          const { exp } = jwt.decode(accessToken);
          logger.info(`access token will expire on ${localeDateTime(new Date(exp * 1000))}`);
        }
        return next(); // Safe to proceed
      }
    });
  } catch (err) {
    if (err instanceof TokenExpiredError) {
      logger.error("verifyAccessToken: token expired:", err.message);
      return res.status(401).json({
        message: req.t("Session is expired, please make a new signin request"),
        code: "EXPIRED_TOKEN",
      });
    }

    logger.error("verifyAccessToken: token verification failed:", err.message);
    return res.status(401).json({
      message:
        req.t("Session is not valid, please make a new signin request") +
        (config.mode.development ? ` (${err.message})` : ""),
      code: "INVALID_TOKEN",
    });
  }
};

const verifyAccessTokenAllowGuest = (req, res, next) => {
  const accessToken = req.cookies.accessToken;

  if (!accessToken) { // allow guests without verification, if no access token is present
    return next();
  }
  return verifyAccessToken(req, res, next);
};

const verifyAccessTokenForOtherUserIfAdminOtherwiseIfUser = async (req, res, next) => {
  verifyAccessToken(req, res, async () => { // only proceed with valid tokens;
    if (req.parameters.userId) { // a userId was requested: check if she is admin
      if (req.parameters.userId === req.userId) {
        return next(); // the requested user id is the same as the requesting user's id: accept request
      } else { // the requested user id is different from the requesting user's id: check if admin
        if (await isAdministrator(req.userId)) { // the requesting user's id is admin: accept request
          return next();
        } else { // the requesting user's id is not admin: deny request
          return res.status(403).json({ message: req.t("You must have admin role to access another user's data") });
        }
      }
    } else {
      return next(); // a userId was not requested: allow request
    }
  });
};

const verifyNotificationToken = (req, res, next) => {
  const token = req.parameters.token;
 
  if (!token) {
    return res.status(401).json({
      message: req.t("Notification token not present"),
      code: "NO_TOKEN",
    });
  }

  jwt.verify(token, process.env.JWT_NOTIFICATION_TOKEN_SECRET, (err, decoded) => {
    if (err) {
      if (err instanceof TokenExpiredError) {
        return res.status(401).json({
          message: req.t("Notification token expired"),
          code: "EXPIRED_TOKEN",
        });
      }
      return res.status(401).json({
        message: req.t("Notification token is not valid"),
        code: "BAD_TOKEN",
      });
    }
    if (!decoded.id) { // jwt.verify did not error out but did not give an id, should not happen
      return res.status(401).json({
        message: req.t("Notification token has no user id"),
        code: "WRONG_TOKEN",
      });
    }
    req.userId = decoded.id;
    next();
  });
};

const verifyRestrictProducts = async (req, res, next) => {
  if (!req.userId) { // no userId in request: we assume the same limitations as for non-dealers
    req.restrictProducts = config.products.restrictForNonDealers;
  } else {
    if (!await isDealerAtLeast(req.userId)) { // check if request is from a dealer, at least
      req.restrictProducts = config.products.restrictForNonDealers;
    } else { // no limitations
      delete req.restrictProducts;
    }
  }
  return next(); // proceed with the request
};

const isAdmin = async (req, res, next) => {
  if (!req.userId) {
    return res.status(403).json({
      message: req.t("No user"),
      code: "NoUser",
    });
  }
  const result = await isAdministrator(req.userId);
  switch (result) {
  case "InternalServerError":
    return res.status(500).json({
      message: req.t("Internal server error"),
      code: result
    });
  case "UserNotFound":
    return res.status(403).json({
      message: req.t("User not found"),
      code: result
    });
  case false:
    return res.status(403).json({
      message: req.t("You must have admin role for this action"),
      code: result
    });
  case true:
    return next(); // proceed only if admin
  }
};


ON THE CLIENT:

middlewares/Interceptors.js:
import axios from "axios";
import LocalStorage from "../libs/LocalStorage";
import { i18n } from "../i18n";
import cfg from "../config";

/**
 * Version 2: HTTP-only cookies (handled server side)
 *  - no more refreshing the accessToken on the client side
 *  - the client assumes the server manages token lifecycles via cookies
 *  - enabled withCredentials (ensures cookies are sent with every request)
 *  - simplified "401 Unauthorized" handling (if the server indicates
 *    the session is invalid (401), redirect the user to the /signin page without retrying)
 *  - retained maintenance and error handling (the client still handles scenarios
 *    like maintenance mode or 404 errors gracefully)
 *  - request abortion (maintains support for canceling pending requests on user sign-out)
 * 
 * Advantages of this new approach:
 *  - security: tokens are stored securely as HTTP-only cookies, inaccessible to JavaScript;
 *    reduces exposure to XSS attacks
 *  - simplicity: eliminates client-side token storage and refresh complexity
 *  - cross-domain compatibility: the withCredentials flag ensures cookies work seamlessly
 *    across subdomains or different domains (when configured properly on the server)
 *  - scalability: by delegating token management to the server, it becomes easier to adapt
 *    this setup to distributed systems with centralized session stores (like Redis)
 */

// global flag to track sign-out status, to avoid retrying requests after sign-out
const abortControllers = new Map(); // define an abortControllers map

// create axios instance
const createInstance = () => {
  return axios.create({
    baseURL: `${cfg.siteUrl}/api`, // API base URL
    timeout: cfg.api.timeoutSeconds * 1000,
    headers: {
      "Content-Type": "application/json",
    },
    withCredentials: true, // ensures cookies are sent with requests
  });
};

const instance = createInstance();
console.log(`axios instance base url is ${instance.defaults.baseURL}`);

// add request interceptor for appending additional headers
instance.interceptors.request.use(
  (config) => {
    // append the current language to request headers
    const currentLanguage = i18n.language || i18n.options.fallbackLng[0]; // get the current language from i18n
    config.headers["Accept-Language"] = currentLanguage;

    // append API version
    if (typeof config.headers["Accept-Version"] === "undefined") {
      const versionNumber = cfg.api.version;
      if (typeof versionNumber !== "undefined") {
        config.headers["Accept-Version"] = versionNumber;
      }
    }

    // add an AbortController for request cancellation
    const controller = new AbortController();
    config.signal = controller.signal;

    // track the controller for this request
    abortControllers.set(config.url, controller);

    return config;
  },
  (error) => Promise.reject(error)
);

// clean up the abort controller after the request completes
instance.interceptors.response.use(
  (response) => {
    abortControllers.delete(response.config.url);
    return response;
  },
  (error) => {
    if (error.config) {
      abortControllers.delete(error.config.url);
    }
    return Promise.reject(error);
  }
);

// add response interceptor for error handling
instance.interceptors.response.use(
  (response) => response,
  async (error) => {
    const { response } = error;

    // handle server maintenance status
    if (response?.status === 503) {
      if (window.location.pathname !== "/work-in-progress") {
        LocalStorage.set("maintenanceStatus", true); // track maintenance status
        LocalStorage.set("maintenancePath", window.location.pathname); // track the user's path
        window.location.href = "/work-in-progress";
      }
    } else if (response) {
      LocalStorage.remove("maintenanceStatus");
      const maintenancePath = LocalStorage.get("maintenancePath");
      if (maintenancePath) {
        window.location.href = maintenancePath; // redirect back to the user's path post-maintenance
        LocalStorage.remove("maintenancePath");
      }
    }

    return Promise.reject(error); // no response from server
  }
);

// cancel all pending requests when the user signs out
export const cancelAllRequests = () => {
  abortControllers.forEach((controller) => controller.abort());
  abortControllers.clear();
};

export default instance;


providers/AuthProvider.jsx:
import { useState, useEffect, useCallback, useRef } from "react";
import { AuthContext } from "./AuthContext";
import { useNavigate } from "react-router-dom";
import { usePersistedState } from "../hooks/usePersistedState";
import { apiCall } from "../libs/Network";
import config from "../config";

const initialStateUser = { user: null };
const initialStatePreferences = {
  locale: config.serverLocale,
  theme: config.ui.defaultTheme
};

const AuthProvider = (props) => {
  const [auth, setAuth] = usePersistedState("auth", initialStateUser);
  const [guest, setGuest] = usePersistedState("guest", initialStateUser);

  const isLoggedIn = !!auth.user;
  const didSignInBefore = auth.user !== null;
  const [preferences, setPreferences] = useState(
    isLoggedIn ? auth.user?.preferences : initialStatePreferences
  );

  const isPWAInstalled = isLoggedIn ? auth.user?.isPWAInstalled === true : false;
  const sessionTimerRef = useRef(null);
  const navigate = useNavigate();

  const clearSessionTimer = useCallback(() => {
    if (sessionTimerRef.current) {
      clearTimeout(sessionTimerRef.current);
      sessionTimerRef.current = null;
    }
  }, []);

  const signOut = useCallback(async () => {
    let ok = false;
    if (isLoggedIn) {
      try {
        console.info("signOut - auth.user.id:", auth.user.id); // TODO: DEBUG ONLY
        const result = await apiCall("post", "/auth/signout", {
          userId: auth.user.id
        });
        if (result.err) {
          if (result.code === "EXPIRED_TOKEN") {
            console.log("token is expired, sign out on server ineffective");
          } else {
            console.error("sign out error:", result.message);
          }
        } else {
          ok = true;
          console.log("sign out successful", result);
        }
      } catch (error) {
        console.error("sign out error:", error);
      }
      clearSessionTimer();
      setAuth({ user: false });
      setPreferences(guest.preferences);
    } else {
      console.warn("already signed out");
    }
    return ok;
  }, [auth.user, clearSessionTimer, setAuth, isLoggedIn, guest.preferences]);

  const startSessionTimer = useCallback((expiresAt) => {
    clearSessionTimer();
    if (!expiresAt) return;

    const msUntilExpiry = new Date(expiresAt).getTime() - Date.now();
    if (msUntilExpiry > 0) {
      sessionTimerRef.current = setTimeout(() => {
        console.warn("Session expired (timer)");
        signOut("expired");
        navigate("/signin", { replace: true, state: { reason: "expired" } });
      }, msUntilExpiry);
    }
  }, [navigate, clearSessionTimer, signOut]);

  /**
   * API + user preference helpers
   */
  const updateUserPreferences = useCallback(async (user, preferences) => {
    try {
      const result = await apiCall("post", "/user/updateUser", {
        _id: user.id,
        preferences
      });
      if (result.err) console.error("update user error:", result.err);
      else console.log("update user successful", result);
    } catch (error) {
      console.error("update user error:", error);
    }
  }, []);

  /**
   *  Auth core actions
   */
  // Now that signOut exists, we can safely rebind startSessionTimer’s dependency
  // (React will do this automatically since it's stable via useCallback)
  const signIn = useCallback(
    async (user) => {
      if (!user) {
        console.debug("AuthProvider.signIn: no user, skipping");
        return false;
      }
      if (auth.user && auth.user.id === user.id) {
        console.debug("AuthProvider.signIn: same user, skipping");
        return false;
      }
      console.log("AuthProvider.signIn, user:", user);
      setAuth({ user });
      if (user?.preferences) setPreferences(user.preferences);
      if (user?.refreshTokenExpiresAt) {
        startSessionTimer(user.refreshTokenExpiresAt);
      }

      return true; // signal a real change
    },
    [auth.user, setAuth, setPreferences, startSessionTimer]
  );

  const updateSignedInUserPreferences = async (user) => {
    console.log("AuthProvider updateSignedInUserPreferences, user:", user);
    setAuth({ user });
    if (user && user.preferences) {
      setPreferences(user.preferences);
    }
    };
  
  const revoke = useCallback(async () => {
    let ok = false;
    if (auth.user !== null) {
      clearSessionTimer();
      setAuth({ user: null });
      console.log("Setting auth to", { user: null });
      setPreferences(guest.preferences);
      ok = true;
    } else {
      console.warn("already revoked");
    }
    return ok;
  }, [auth.user, clearSessionTimer, setAuth, guest.preferences]);

  /**
   *  Preferences + UI updates
   */
  const changeLocale = useCallback(
    (locale) => {
      const newPreferences = { ...preferences, locale };
      setPreferences(newPreferences);

      if (isLoggedIn && auth.user) {
        setAuth({
          user: {
            ...auth.user,
            preferences: newPreferences
          }
        });
        updateUserPreferences(auth.user, newPreferences);
      } else {
        setGuest({
          user: { preferences: newPreferences }
        });
      }
    },
    [
      preferences,
      setPreferences,
      updateUserPreferences,
      setAuth,
      setGuest,
      isLoggedIn,
      auth.user
    ]
  );

  const toggleTheme = useCallback(() => {
    const newPreferences = {
      ...preferences,
      theme: preferences.theme === "light" ? "dark" : "light"
    };
    setPreferences(newPreferences);

    if (isLoggedIn && auth.user) {
      setAuth({
        user: {
          ...auth.user,
          preferences: newPreferences
        }
      });
      updateUserPreferences(auth.user, newPreferences);
    } else {
      setGuest({
        user: {
          ...guest.user,
          preferences: newPreferences
        }
      });
    }
  }, [
    preferences,
    setPreferences,
    updateUserPreferences,
    setAuth,
    setGuest,
    isLoggedIn,
    auth.user,
    guest.user
  ]);

  const cloneGuestUserPreferencesToAuthUser = useCallback(
    (user) => {
      if (guest.user?.preferences) {
        const guestPreferences = guest.user.preferences;
        const newUser = { ...user, preferences: guestPreferences };
        setAuth({ user: newUser });
      }
    },
    [guest.user, setAuth]
  );

  const updateSignedInUserLocally = useCallback(
    (updatedFields) => {
      setAuth((prevAuth) => ({
        user: {
          ...prevAuth.user,
          ...updatedFields
        }
      }));
    },
    [setAuth]
  );

  const setPWAInstalled = useCallback(
    (how) => {
      if (auth.user) {
        setAuth({
          user: {
            ...auth.user,
            PWAInstalled: how
          }
        });
      }
    },
    [auth.user, setAuth]
  );

  /**
   *  Effects
   */
  useEffect(() => {
    if (auth.user?.refreshTokenExpiresAt) {
      startSessionTimer(auth.user.refreshTokenExpiresAt);
    }
    return () => clearSessionTimer();
  }, [auth.user?.refreshTokenExpiresAt, startSessionTimer, clearSessionTimer]);

  /**
   *  Render
   */
  return (
    <AuthContext.Provider
      value={{
        auth,
        guest,
        preferences,
        isLoggedIn,
        didSignInBefore,
        signIn,
        updateSignedInUserPreferences,
        signOut,
        revoke,
        changeLocale,
        toggleTheme,
        cloneGuestUserPreferencesToAuthUser,
        updateSignedInUserLocally,
        isPWAInstalled,
        setPWAInstalled
      }}
    >
      {props.children}
    </AuthContext.Provider>
  );
};

export { AuthProvider };

App.jsx:
const AppStructure = () => {
  const [loading] = useAxiosLoader();
  const { preferences, changeLocale, toggleTheme } = useContext(AuthContext);
  const [isDarkMode, setIsDarkMode] = useState(config.ui.defaultTheme !== "light");
  
  // Get the responsive theme based on current mode and screen size
  const theme = useResponsiveTheme(isDarkMode);

  // Function to set theme
  const setTheme = (themeName) => {
    setIsDarkMode(themeName === "dark");
  };
  
  useEffect(() => {
    if (preferences && preferences.theme) {
      setTheme(preferences.theme);
    }
  }, [preferences]);

  const themeToggle = () => {
    //setTheme((prevTheme) => (prevTheme.palette.mode));
    toggleTheme();
  };

  return (
    <ThemeProvider theme={theme}>
      <CartProvider>
        <MediaQueryProvider>
          <DialogProvider>
            <ServiceWorkerMessages />
            <ServiceWorkerProvider>
              <OnlineStatusProvider>
                <CssBaseline />
                <LoaderProvider>
                  <Loader loading={loading} />
                  {/* <SessionExpirationHandler> */}
                  {/* <BackgroundVideo /> */}
                  {/* <SessionProvider /> */}
                  <JobProvider>
                    <InstallPWA />
                    <PreferencesCookie />
                    {config.mode.development && <ClientInfoDisplay theme={theme} />}                      
                    <Contents theme={theme} changeLocale={changeLocale} toggleTheme={themeToggle}>
                      <Routing />
                    </Contents>
                  </JobProvider>
                  {/* </SessionExpirationHandler> */}
                </LoaderProvider>
              </OnlineStatusProvider>
            </ServiceWorkerProvider>
          </DialogProvider>
        </MediaQueryProvider>
      </CartProvider>
    </ThemeProvider>
  );
};